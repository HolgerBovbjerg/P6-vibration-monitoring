//////////////////////////////////////////////////////////////////////////////
// * File name: main.c
// *                                                                          
// * Description: This file includes main() and system initialization funcitons.
// *                                                                          
// * Copyright (C) 2010 Texas Instruments Incorporated - http://www.ti.com/ 
// *                                                                          
// *                                                                          
// *  Redistribution and use in source and binary forms, with or without      
// *  modification, are permitted provided that the following conditions      
// *  are met:                                                                
// *                                                                          
// *    Redistributions of source code must retain the above copyright        
// *    notice, this list of conditions and the following disclaimer.         
// *                                                                          
// *    Redistributions in binary form must reproduce the above copyright     
// *    notice, this list of conditions and the following disclaimer in the   
// *    documentation and/or other materials provided with the                
// *    distribution.                                                         
// *                                                                          
// *    Neither the name of Texas Instruments Incorporated nor the names of   
// *    its contributors may be used to endorse or promote products derived   
// *    from this software without specific prior written permission.         
// *                                                                          
// *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS     
// *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT       
// *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   
// *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    
// *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   
// *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT        
// *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   
// *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   
// *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     
// *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   
// *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    
// *                                                                          
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// * Change History:
// * May 11, 2010:                                                                          
// * BugFix: PLL_100M was undefined, which failed to configure the PLL when
// * running in stand-alone mode. PLL was set to 100MHz by GEL file when running                                                                          
// * from Code Composer.
//////////////////////////////////////////////////////////////////////////////

#define PLL_12M		0
#define PLL_98M		0
#define PLL_100M	1

#include <stdio.h>
#include "data_types.h"
#include "register_system.h"
#include "register_cpu.h"
#include "rtc_routines.h"
#include "i2s_routines.h"
#include "dma_routines.h"
#include "configuration.h"
#include "hwafft.h"
#include "filter_routines.h"


void InitSystem(void);
void ConfigPort(void);
void SYS_GlobalIntEnable(void);
void SYS_GlobalIntDisable(void);
void PLL_98MHz(void);

void turnOnLED(void);
void turnOffLED(void);

Uint16 fFilterOn = 0;
Uint16 fBypassOn = 1;
Uint16 clearOverlaps = 1;

extern void AIC3204_init(void);
extern Uint16 CurrentRxL_DMAChannel;
extern Uint16 CurrentRxR_DMAChannel;
extern Uint16 CurrentTxL_DMAChannel;
extern Uint16 CurrentTxR_DMAChannel;
extern Uint16 RunFilterForL;
extern Uint16 RunFilterForR;


void main(void)
{
    #if DEBUG||(SOURCE != FROM_CODEC)
    	Int16 i;
    #endif

	#if (SOURCE != FROM_CODEC)
		Int16 Sim_Index_L = 0;
		Int16 Sim_Index_R = 0;
	#endif

	Int32 *FilterIn;		// Pointer to filter input buffer

    InitSystem();

	Zero_Pad_Inputs();		// Zero-pad the input buffers in advance (zeros will not be overwritten)
	Clear_COLA_Overlaps();	// Zero overlap buffers that hold Constant-Overlap-and-Add samples
	FFT_Coeffs();			// Zero-pad and FFT coefficients outside of loop

    ConfigPort();
    SYS_GlobalIntEnable();
	reset_RTC();    
    
    IER0 = 0x0110;      	// enable dma, timer int      
    IER1 = 0x0004;      	// enable RTC int

    setDMA_address();
    //set_i2s0_master();	// I2S0_CLK and I2S0_FS pins of DSP configured as outputs
    set_i2s0_slave();		// I2S0_CLK and I2S0_FS pins of DSP configured as inputs
    AIC3204_init();

    PLL_98MHz();

	enable_i2s0();
    enable_dma_int();
    set_dma0_ch0_i2s0_Lout();
    set_dma0_ch1_i2s0_Rout();
    set_dma0_ch2_i2s0_Lin();
	set_dma0_ch3_i2s0_Rin();
	enable_rtc_second_int();

    while(1)
    {
        //FilterOn: Pass samples to the FFT Filter, then Overlap and Add consecutive filter outputs
        while(fFilterOn)
        {
            turnOnLED();
            if(RunFilterForL ==1)
            {
                RunFilterForL =0;

				if (CurrentRxL_DMAChannel ==2)
                {
					#if (SOURCE != FROM_CODEC)			
						// Read samples from memory, ignore input from codec
						for(i=0;i<WINDOW_SIZE;i++)
						{	
							RcvL1_copy[i] = ((Int32)Simulation[Sim_Index_L] << 16);
							Sim_Index_L++;
							if(Sim_Index_L >= SIM_BUFF_SIZE)
								Sim_Index_L -= SIM_BUFF_SIZE;
						}
						FilterIn = &RcvL1_copy[0];
						
					#elif DEBUG
						// Make a copy of the input samples before filtering (for debugging)
						buff_copy32(&RcvL1[0], &RcvL1_copy[0], WINDOW_SIZE);
						FilterIn = &RcvL1_copy[0];
						
					#else
						// Filter inputs from the codec
						FilterIn = &RcvL1[0];
					#endif

					FFT_Filter(&FilterIn[0], &FilterOut[0]);
					COLA_Output(&FilterOut[0], &OverlapL[0], &XmitL1[0]);		
				}
                else
                {				
					#if (SOURCE != FROM_CODEC)
						// Read samples from memory, ignore input from codec
						for(i=0;i<WINDOW_SIZE;i++)
						{	
							RcvL2_copy[i] = ((Int32)Simulation[Sim_Index_L] << 16);
							Sim_Index_L++;
							if(Sim_Index_L >= SIM_BUFF_SIZE)
								Sim_Index_L -= SIM_BUFF_SIZE;
						}
						FilterIn = &RcvL2_copy[0];
						
					#elif DEBUG
						buff_copy32(&RcvL2[0], &RcvL2_copy[0], WINDOW_SIZE);
						FilterIn = &RcvL2_copy[0];
						
					#else
						FilterIn = &RcvL2[0];
					#endif

					FFT_Filter(&FilterIn[0], &FilterOut[0]);
					COLA_Output(&FilterOut[0], &OverlapL[0], &XmitL2[0]);
                }
            }
            if(RunFilterForR ==1)
            {
                RunFilterForR=0;
                if (CurrentRxR_DMAChannel ==2)
                {
					#if (SOURCE != FROM_CODEC)
						// Read samples from memory, ignore input from codec
						for(i=0;i<WINDOW_SIZE;i++)
						{	
							RcvR1_copy[i] = ((Int32)Simulation[Sim_Index_R] << 16);
							Sim_Index_R++;
							if(Sim_Index_R >= SIM_BUFF_SIZE)
								Sim_Index_R -= SIM_BUFF_SIZE;
						}
						FilterIn = &RcvR1_copy[0];
						
					#elif DEBUG
						buff_copy32(&RcvR1[0], &RcvR1_copy[0], WINDOW_SIZE);
						FilterIn = &RcvR1_copy[0];
						
					#else
						FilterIn = &RcvR1[0];
					#endif

					FFT_Filter(&FilterIn[0], &FilterOut[0]);
					COLA_Output(&FilterOut[0], &OverlapR[0], &XmitR1[0]);
                }
                else
                {
					#if (SOURCE != FROM_CODEC)
					// Read samples from memory, ignore input from codec
						for(i=0;i<WINDOW_SIZE;i++)
						{	
							RcvR2_copy[i] = ((Int32)Simulation[Sim_Index_R] << 16);
							Sim_Index_R++;
							if(Sim_Index_R >= SIM_BUFF_SIZE)
								Sim_Index_R -= SIM_BUFF_SIZE;
						}
						FilterIn = &RcvR2_copy[0];
						
					#elif DEBUG
						buff_copy32(&RcvR2[0], &RcvR2_copy[0], WINDOW_SIZE);
						FilterIn = &RcvR2_copy[0];
						
					#else
						FilterIn = &RcvR2[0];
					#endif

					FFT_Filter(&FilterIn[0], &FilterOut[0]);
					COLA_Output(&FilterOut[0], &OverlapR[0], &XmitR2[0]);
                }
            }
        }
		// BypassOn: Copy Samples directly from source to destination without filtering
        while(fBypassOn)
        {
            turnOffLED();
			if (clearOverlaps ==1)
			{
				clearOverlaps = 0;
				Clear_COLA_Overlaps();
			}

            if(RunFilterForL ==1)
            {
                RunFilterForL =0;             
                if (CurrentRxL_DMAChannel ==2)
                {
                    #if (SOURCE != FROM_CODEC)
						// Read samples from memory, ignore input from codec
						for(i=0;i<WINDOW_SIZE;i++)
						{	
							XmitL1[i] = ((Int32)Simulation[Sim_Index_L] << 16);
							Sim_Index_L++;
							if(Sim_Index_L >= SIM_BUFF_SIZE)
								Sim_Index_L -= SIM_BUFF_SIZE;
						}
						
                	#else
                    	buff_copy32(&RcvL1[0], &XmitL1[0], WINDOW_SIZE);	
					#endif			
				}
                else
                {
					#if (SOURCE != FROM_CODEC)
						// Read samples from memory, ignore input from codec
						for(i=0;i<WINDOW_SIZE;i++)
						{	
							XmitL2[i] = ((Int32)Simulation[Sim_Index_L] << 16);
							Sim_Index_L++;
							if(Sim_Index_L >= SIM_BUFF_SIZE)
								Sim_Index_L -= SIM_BUFF_SIZE;
						}
						
                	#else
                    	buff_copy32(&RcvL2[0], &XmitL2[0], WINDOW_SIZE);
					#endif     
				}
                
            }
            if(RunFilterForR ==1)
            {
                RunFilterForR=0;
                if (CurrentRxR_DMAChannel ==2)
                {
					#if (SOURCE != FROM_CODEC)
						// Read samples from memory, ignore input from codec
						for(i=0;i<WINDOW_SIZE;i++)
						{	
							XmitR1[i] = ((Int32)Simulation[Sim_Index_R] << 16);
							Sim_Index_R++;
							if(Sim_Index_R >= SIM_BUFF_SIZE)
								Sim_Index_R -= SIM_BUFF_SIZE;
						}
						
                	#else
                    	buff_copy32(&RcvR1[0], &XmitR1[0], WINDOW_SIZE);
					#endif
                }
                else
                {
					#if (SOURCE != FROM_CODEC)
						// Read samples from memory, ignore input from codec
						for(i=0;i<WINDOW_SIZE;i++)
						{	
							XmitR2[i] = ((Int32)Simulation[Sim_Index_R] << 16);
							Sim_Index_R++;
							if(Sim_Index_R >= SIM_BUFF_SIZE)
								Sim_Index_R -= SIM_BUFF_SIZE;
						}
						
                	#else
                    	buff_copy32(&RcvR2[0], &XmitR2[0], WINDOW_SIZE);
					#endif
                }
            }
        }
    }

}

void PLL_98MHz(void)
{
	// PLL set up from RTC
    // bypass PLL
    CONFIG_MSW = 0x0;

#if (PLL_100M ==1)
    PLL_CNTL2 = 0x8000;
    PLL_CNTL4 = 0x0000;
    PLL_CNTL3 = 0x0806;
    PLL_CNTL1 = 0x82FA;
    
#elif (PLL_12M ==1)
    PLL_CNTL2 = 0x8000;
    PLL_CNTL4 = 0x0200;
    PLL_CNTL3 = 0x0806;
    PLL_CNTL1 = 0x82ED;
#elif (PLL_98M ==1)    
    PLL_CNTL2 = 0x8000;
    PLL_CNTL4 = 0x0000;
    PLL_CNTL3 = 0x0806;
    PLL_CNTL1 = 0x82ED;
    
#endif
    while ( (PLL_CNTL3 & 0x0008) == 0);
    // Switch to PLL clk
    CONFIG_MSW = 0x1;
}

void InitSystem(void)
{
	Uint16 i;
	// PLL set up from RTC
    // bypass PLL
    CONFIG_MSW = 0x0;

#if (PLL_100M ==1)
    PLL_CNTL2 = 0x8000;
    PLL_CNTL4 = 0x0000;
    PLL_CNTL3 = 0x0806;
    PLL_CNTL1 = 0x82FA;
    
#elif (PLL_12M ==1)
    PLL_CNTL2 = 0x8000;
    PLL_CNTL4 = 0x0200;
    PLL_CNTL3 = 0x0806;
    PLL_CNTL1 = 0x82ED;
#elif (PLL_98M ==1)    
    PLL_CNTL2 = 0x8000;
    PLL_CNTL4 = 0x0000;
    PLL_CNTL3 = 0x0806;
    PLL_CNTL1 = 0x82ED;

#elif (PLL_40M ==1)        
    PLL_CNTL2 = 0x8000;
    PLL_CNTL4 = 0x0300;
    PLL_CNTL3 = 0x0806;
    PLL_CNTL1 = 0x8262;    
#endif

    while ((PLL_CNTL3 & 0x0008) == 0);
    // Switch to PLL clk
    CONFIG_MSW = 0x1;

	// clock gating
	// enable all clocks
    IDLE_PCGCR = 0x0;
    IDLE_PCGCR_MSW = 0xFF84;
    

	// reset peripherals
    PER_RSTCOUNT = 0x02;
    PER_RESET = 0x00fb;    
    for (i=0; i< 0xFFF; i++);
}

void ConfigPort(void)
{
    Int16 i;
    //  configure ports
    PERIPHSEL0 = 0x6900;        // parallel port: mode 6, serial port1: mode 2 

    for (i=0; i< 0xFFF; i++);
}


void SYS_GlobalIntEnable(void)
{
    asm(" BIT (ST1, #ST1_INTM) = #0");
}

void SYS_GlobalIntDisable(void)
{
    asm(" BIT (ST1, #ST1_INTM) = #1");
}

void turnOnLED(void)
{
    Uint16 temp;
    
    temp = ST1_55;
    if((temp&0x2000) == 0)
    {
        // turn on LED
        temp |= 0x2000;
        ST1_55 =temp;
    }
    
}

void turnOffLED(void)
{
    Uint16 temp;
    
    temp = ST1_55;
    if((temp&0x2000) != 0)
    {
        // turn off LED
        temp &=0xDFFF;
        ST1_55 =temp;
    }
}


